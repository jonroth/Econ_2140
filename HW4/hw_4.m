cd '/Users/jonathanroth/Google Drive/Econ 2140/HW4/';

%% Import data from text file.
% Script for importing data from the following text file:
%
%    /Users/jonathanroth/Google Drive/Econ 2140/HW4/weco3.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2015/03/24 16:20:01

%% Initialize variables.
filename = '/Users/jonathanroth/Google Drive/Econ 2140/HW4/weco3.csv';
delimiter = ',';
startRow = 2;

%% Format string for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
%	column6: double (%f)
%   column7: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%f%f%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'HeaderLines' ,startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
prod1 = dataArray{:, 1};
sex = dataArray{:, 2};
dex = dataArray{:, 3};
lex = dataArray{:, 4};
quit1 = dataArray{:, 5};
job_tenure = dataArray{:, 6};
status = dataArray{:, 7};


%% Clear temporary variables
clearvars filename delimiter startRow formatSpec fileID dataArray ans;


%%

%Create the matrix of covariates, and save its length and width as n and k
n = length(dex);
X = [ones(n,1) sex dex lex lex.^2];
k = size(X,2);



Y = job_tenure;
Z = status;

%Initialize values for alpha and beta for the newton raphson algo
alpha = 1;
beta = zeros(k,1);

%Create inline functions gfn(theta) and hfn(theta) to pass to the newton
%raphson algorithm. Most of the work goes through the duration_gh function,
%which runs the loop over observations and returns g(theta) and h(theta)
gfn = @(theta) duration_gh(theta(1), theta(2:(k+1)), job_tenure,X, status);
hfn = @(theta) hfn_help(theta(1), theta(2:(k+1)), job_tenure,X, status);

%Compute the MLE, theta
theta = newtonraphson(gfn,hfn,[alpha; beta] ,10^(-6))

%Compute standard errors using the diagnol of the Hessian at the MLE theta
se = sqrt(diag(inv(-hfn(theta))))

%Calulate the t-stat for alpha under the null that alpha = 1
t = (theta(1) - 1)/ se(1)


%% Part 2

%2 a)

normK = @(X) normpdf(X);
%Calculate the optimal bandwidth using normal ref rule
h_star = 1.059*std(prod1)/n^(1/5)
%Calculate the densities using normal kernel
fhat = f_kern(prod1,prod1,normK,h_star);

scatter(prod1,fhat)


%2 b)

%Create a vector of h's
hvec = [0.01:0.01:1];
%Initiate a vector of cv values equal to 0
cv_vec = zeros(length(hvec),1);

%Save a handle for the kern_nw function
nw_kernel = @kern_nw;

%Compute the CV for each h in h_vec
for ind = 1:length(hvec)
    cv_vec(ind) = reg_cv(prod1,job_tenure, nw_kernel, normK,hvec(ind));
end

%Calculate the min
[~,min_ind] = min(cv_vec);
h_min = hvec(min_ind)

%yhat = kern_nw(prod1,prod1,job_tenure, normK,h_min)
%Plot the predicted values for a grid from 10 to 20
xgrid =[10:.01:20]';
[yhat, W] = kern_nw(xgrid,prod1,job_tenure, normK,h_min);


scatter(prod1,job_tenure)
hold on
scatter(xgrid,yhat,3)
hold off



%Part 2 c)

%Create a vector of h's from 1 to 3
hvec = [1:0.01:3];
%Initiate a vector of cv values equal to 0
cv_vec = zeros(length(hvec),1);
%Save a handle for the kern_lin function
lin_kern = @kern_lin;

%Compute the CV for each h in h_vec
for ind = 1:length(hvec)
    cv_vec(ind) = reg_cv(prod1,job_tenure, lin_kern, normK,hvec(ind));
end

%Calculate the min
[~,min_ind] = min(cv_vec);
h_min_lin = hvec(min_ind)



tic
yhat_lin = kern_lin(xgrid, prod1, job_tenure, normK, h_min_lin)
%yhat_lin = kern_lin(prod1,prod1,job_tenure, normK,h_min)
toc

scatter(prod1,job_tenure)
hold on
scatter(xgrid,yhat_lin,3)
%scatter(prod1,yhat_lin,3)
hold off



testfn = @(x,y) x+y;
x1 = 1:5;
x2 = 5:9;
arrayfun(testfn,x1,x2,'UniformOutput',false)
